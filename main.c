#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <pthread.h>

#include <SDL.h>
#include <SDL_ttf.h>
#include <SDL_mixer.h>
#include <SDL_image.h>
#include <curl/curl.h>
#include <jansson.h>

#include "config.h"

// This header is generated by running `xxd -i <your_font_file.ttf> > font_data.h`
#include "font_data.h"

// --- Font Data Configuration ---
// The `xxd -i` command creates variable names based on the input filename.
// For example, if your font file is named `my_font.ttf`, the variables in
// font_data.h will be `my_font_ttf` and `my_font_ttf_len`.
//
// **ACTION**: These macros have been updated to match your 'PressStart2P-Regular.ttf' file.
#define EMBEDDED_FONT_ARRAY PressStart2P_Regular_ttf
#define EMBEDDED_FONT_LEN   PressStart2P_Regular_ttf_len


#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// --- Display & Timing Constants ---
#define SCREEN_WIDTH 800
#define SCREEN_HEIGHT 600
#define REFRESH_INTERVAL_MS 5000
#define DISPLAY_TIMEOUT_MS 1500
#define PLANE_ICON_SCALE 0.1f

// --- Radar Constants ---
#define EARTH_RADIUS_KM 6371.0
#define RADAR_CENTER_X (SCREEN_WIDTH * 0.7)
#define RADAR_CENTER_Y (SCREEN_HEIGHT / 2)
#define RADAR_RADIUS (SCREEN_HEIGHT * 0.4)

// --- Audio Constants ---
#define AUDIO_FREQ 44100
#define AUDIO_SAMPLES 2048
#define ALT_LOW_FEET 10000
#define ALT_HIGH_FEET 30000
#define FREQ_LOW 800
#define FREQ_MID 1200
#define FREQ_HIGH 1800

// --- Color Scheme ---
const SDL_Color COLOR_BG        = {16, 16, 20, 255};
const SDL_Color COLOR_RADAR     = {0, 200, 100, 255};
const SDL_Color COLOR_TEXT      = {240, 240, 240, 255};
const SDL_Color COLOR_ALERT     = {255, 80, 80, 255};
const SDL_Color COLOR_OVERLAY_BG = {0, 0, 40, 200};

// --- Data Structs ---
typedef struct {
    char flight[10];
    char hex[10];
    double distanceKm;
    double bearing; // bearing from receiver to aircraft
    double heading; // direction of travel
    double lat;
    double lon;
    int altitude;
    float groundSpeed;
    bool inbound;
    bool isValid;
} Aircraft;

typedef struct {
    int x;
    int y;
    Uint32 spawnTime;
    double bearing; // visual orientation
    bool inbound;
    int minutesToBase; // minutes until closest approach, -1 if unknown
} RadarBlip;

// --- Control State ---
typedef enum { VOLUME, SPEED } ControlMode;
ControlMode currentMode = VOLUME;

// --- Global State Variables ---
bool app_is_running = true;
bool dataConnectionOk = false;
Aircraft lastPingedAircraft = { .isValid = false, .inbound = false };
Aircraft* trackedAircraft = NULL;
int trackedAircraftCount = 0;
RadarBlip* activeBlips = NULL;
int activeBlipsCount = 0;
pthread_mutex_t dataMutex;
double receiverLat = USER_LAT;
double receiverLon = USER_LON;

// --- Control & Display Variables ---
int beepVolume = 10; // 0-20
float rangeSteps[] = {5, 10, 25, 50, 100, 150, 200, 300};
const int rangeStepsCount = sizeof(rangeSteps) / sizeof(rangeSteps[0]);
int rangeStepIndex = 3;
float radarRangeKm;
float inboundAlertDistanceKm = INBOUND_ALERT_DISTANCE_KM;
float sweepSpeedSteps[] = {90.0, 180.0, 270.0, 360.0};
const int speedStepsCount = sizeof(sweepSpeedSteps) / sizeof(sweepSpeedSteps[0]);
int sweepSpeedIndex = 1;
float sweepSpeed;
Uint32 displayTimeout = 0;
char displayMessage[100];
bool displayAlert = false;

// --- Animation & Audio State ---
float sweepAngle = 0.0;
float lastSweepAngle = 0.0;
bool* paintedThisTurn = NULL;
int beep_freq = 0;
int beep_duration_ms = 0;
volatile int beep_samples_left = 0;

// --- Function Prototypes ---
double deg2rad(double deg);
double haversine(double lat1, double lon1, double lat2, double lon2);
double calculateBearing(double lat1, double lon1, double lat2, double lon2);
void drawText(SDL_Renderer* renderer, TTF_Font* font, const char* text, int x, int y, SDL_Color color, bool center);
void drawDottedCircle(SDL_Renderer *renderer, int32_t centreX, int32_t centreY, int32_t radius);
void SDL_RenderDrawCircle(SDL_Renderer * renderer, int32_t centreX, int32_t centreY, int32_t radius);
void drawPlaneIcon(SDL_Renderer* renderer, int x, int y, double angle, Uint8 alpha);

// --- Networking ---
struct MemoryStruct { char *memory; size_t size; };

static size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    struct MemoryStruct *mem = (struct MemoryStruct *)userp;
    char *ptr = realloc(mem->memory, mem->size + realsize + 1);
    if(!ptr) { printf("not enough memory (realloc returned NULL)\n"); return 0; }
    mem->memory = ptr;
    memcpy(&(mem->memory[mem->size]), contents, realsize);
    mem->size += realsize;
    mem->memory[mem->size] = 0;
    return realsize;
}

void* fetchDataTask(void *arg) {
    CURLcode res;
    struct MemoryStruct chunk;
    char url[200];
    snprintf(url, sizeof(url), "http://%s:%d/dump1090-fa/data/aircraft.json", DUMP1090_SERVER, DUMP1090_PORT);

    curl_global_init(CURL_GLOBAL_ALL);
    CURL *curl_handle = curl_easy_init();
    if (!curl_handle) {
        fprintf(stderr, "curl_easy_init() failed\n");
        curl_global_cleanup();
        return NULL;
    }

    curl_easy_setopt(curl_handle, CURLOPT_URL, url);
    curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
    curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, "libcurl-agent/1.0");
    curl_easy_setopt(curl_handle, CURLOPT_TIMEOUT_MS, 4000L);

    // Attempt to fetch receiver location once so blip positions match server map
    chunk.memory = malloc(1);
    if (chunk.memory) {
        chunk.size = 0;
        char rxUrl[200];
        snprintf(rxUrl, sizeof(rxUrl), "http://%s:%d/dump1090-fa/data/receiver.json", DUMP1090_SERVER, DUMP1090_PORT);
        curl_easy_setopt(curl_handle, CURLOPT_URL, rxUrl);
        curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&chunk);
        if (curl_easy_perform(curl_handle) == CURLE_OK) {
            json_error_t rerror;
            json_t *rroot = json_loads(chunk.memory, 0, &rerror);
            if (rroot) {
                json_t *lat_j = json_object_get(rroot, "lat");
                json_t *lon_j = json_object_get(rroot, "lon");
                if (json_is_real(lat_j) && json_is_real(lon_j)) {
                    receiverLat = json_real_value(lat_j);
                    receiverLon = json_real_value(lon_j);
                }
                json_decref(rroot);
            }
        }
        free(chunk.memory);
        curl_easy_setopt(curl_handle, CURLOPT_URL, url);
    }

    while(app_is_running) {
        chunk.memory = malloc(1);
        if (!chunk.memory) {
            fprintf(stderr, "Failed to allocate memory for CURL buffer\n");
            SDL_Delay(REFRESH_INTERVAL_MS);
            continue;
        }
        chunk.size = 0;
        curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&chunk);
        res = curl_easy_perform(curl_handle);

        if(res == CURLE_OK) {
            json_error_t error;
            json_t *root = json_loads(chunk.memory, 0, &error);
            if (root) {
                dataConnectionOk = true;
                json_t *aircraft_array = json_object_get(root, "aircraft");
                if (json_is_array(aircraft_array)) {
                    size_t count = json_array_size(aircraft_array);

                    pthread_mutex_lock(&dataMutex);
                    Aircraft* previous = trackedAircraft;
                    int previousCount = trackedAircraftCount;
                    pthread_mutex_unlock(&dataMutex);

                    Aircraft* planesInRange = malloc(sizeof(Aircraft) * (count > 0 ? count : 1));
                    if (planesInRange) {
                        int planesInRangeCount = 0;

                        for (size_t i = 0; i < count; i++) {
                            json_t *plane = json_array_get(aircraft_array, i);
                            json_t *lat_json = json_object_get(plane, "lat");
                            json_t *lon_json = json_object_get(plane, "lon");

                            if (json_is_real(lat_json) && json_is_real(lon_json)) {
                                double lat = json_real_value(lat_json);
                                double lon = json_real_value(lon_json);
                                double dist = haversine(receiverLat, receiverLon, lat, lon);
                                if (dist < radarRangeKm) {
                                    Aircraft ac = {.isValid = true, .inbound = false};
                                    const char* flightStr = json_string_value(json_object_get(plane, "flight"));
                                    if(flightStr) { strncpy(ac.flight, flightStr, sizeof(ac.flight) - 1); ac.flight[sizeof(ac.flight) - 1] = '\0'; } else { ac.flight[0] = '\0'; }

                                    const char* hexStr = json_string_value(json_object_get(plane, "hex"));
                                    if(hexStr) { strncpy(ac.hex, hexStr, sizeof(ac.hex) - 1); ac.hex[sizeof(ac.hex) - 1] = '\0'; } else { ac.hex[0] = '\0'; }

                                    ac.lat = lat;
                                    ac.lon = lon;
                                    ac.distanceKm = dist;
                                    ac.bearing = calculateBearing(receiverLat, receiverLon, lat, lon);
                                    ac.heading = ac.bearing;

                                    if (previous) {
                                        for (int p = 0; p < previousCount; p++) {
                                            if (strcmp(previous[p].hex, ac.hex) == 0) {
                                                ac.heading = calculateBearing(previous[p].lat, previous[p].lon, lat, lon);
                                                break;
                                            }
                                        }
                                    }

                                    json_t *alt_json = json_object_get(plane, "alt_baro");
                                    if (json_is_integer(alt_json)) ac.altitude = json_integer_value(alt_json); else ac.altitude = -1;

                                    json_t *gs_json = json_object_get(plane, "gs");
                                    if(json_is_real(gs_json)) ac.groundSpeed = json_real_value(gs_json); else ac.groundSpeed = -1.0f;

                                    planesInRange[planesInRangeCount++] = ac;
                                }
                            }
                        }

                        pthread_mutex_lock(&dataMutex);
                        free(previous);
                        trackedAircraft = planesInRange;
                        trackedAircraftCount = planesInRangeCount;
                    // New data arrived, so we need a new paint buffer
                        free(paintedThisTurn);
                        paintedThisTurn = calloc(trackedAircraftCount > 0 ? trackedAircraftCount : 1, sizeof(bool));
                        if (!paintedThisTurn) {
                            dataConnectionOk = false;
                        }
                        pthread_mutex_unlock(&dataMutex);
                    } else {
                        dataConnectionOk = false;
                    }
                }
                json_decref(root);
            } else {
                dataConnectionOk = false;
            }
        } else {
            fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
            dataConnectionOk = false;
            pthread_mutex_lock(&dataMutex);
            trackedAircraftCount = 0;
            lastPingedAircraft.isValid = false;
            pthread_mutex_unlock(&dataMutex);
        }

        free(chunk.memory);
        SDL_Delay(REFRESH_INTERVAL_MS);
    }
    curl_easy_cleanup(curl_handle);
    curl_global_cleanup();
    return NULL;
}

// --- Audio ---
void audio_callback(void *userdata, Uint8 *stream, int len) {
    Sint16 *buffer = (Sint16*)stream;
    int length = len / 2; // 16-bit samples
    static double phase = 0.0;
    
    int samples_to_process = (beep_samples_left < length) ? beep_samples_left : length;
    
    if (samples_to_process > 0) {
        double phase_step = 2.0 * M_PI * beep_freq / AUDIO_FREQ;
        Sint16 amplitude = (Sint16)(3000 * (beepVolume / 20.0));
        for (int i = 0; i < samples_to_process; i++) {
            buffer[i] = (Sint16)(amplitude * sin(phase));
            phase += phase_step;
        }
        beep_samples_left -= samples_to_process;
    }
    
    if (samples_to_process < length) {
        SDL_memset(buffer + samples_to_process, 0, (length - samples_to_process) * sizeof(Sint16));
    }
}

void playBeep(int freq, int duration_ms) {
    if (beep_samples_left > 0) return;
    beep_freq = freq;
    beep_duration_ms = duration_ms;
    SDL_LockAudio();
    beep_samples_left = (int)((AUDIO_FREQ / 1000.0) * duration_ms);
    SDL_UnlockAudio();
}

int getBeepFrequencyForAltitude(int altitude) {
    if (altitude < 0) return FREQ_MID;
    if (altitude < ALT_LOW_FEET) return FREQ_LOW;
    else if (altitude < ALT_HIGH_FEET) return FREQ_MID;
    else return FREQ_HIGH;
}


// --- Main Application ---
int main(int argc, char* argv[]) {
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) != 0) {
        fprintf(stderr, "SDL_Init Error: %s\n", SDL_GetError());
        return 1;
    }
    if (TTF_Init() == -1) {
        fprintf(stderr, "TTF_Init Error: %s\n", TTF_GetError());
        SDL_Quit();
        return 1;
    }
    if (!(IMG_Init(IMG_INIT_PNG) & IMG_INIT_PNG)) {
        fprintf(stderr, "IMG_Init Error: %s\n", IMG_GetError());
        TTF_Quit();
        SDL_Quit();
        return 1;
    }

    SDL_Window* window = SDL_CreateWindow("Closest Plane Radar", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, 0);
    if (!window) {
        fprintf(stderr, "SDL_CreateWindow Error: %s\n", SDL_GetError());
        TTF_Quit(); SDL_Quit(); return 1;
    }
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
     if (!renderer) {
        fprintf(stderr, "SDL_CreateRenderer Error: %s\n", SDL_GetError());
        SDL_DestroyWindow(window); TTF_Quit(); SDL_Quit(); return 1;
    }

    // Try to load a modern system font, fall back to the embedded one if unavailable
    TTF_Font* font = TTF_OpenFont("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 24);
    if (!font) {
        SDL_RWops* font_mem = SDL_RWFromConstMem(EMBEDDED_FONT_ARRAY, EMBEDDED_FONT_LEN);
        font = TTF_OpenFontRW(font_mem, 1, 24);
    }
    if (!font) { fprintf(stderr, "Failed to load main font: %s\n", TTF_GetError()); /* continue anyway */ }

    TTF_Font* small_font = TTF_OpenFont("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 18);
    if (!small_font) {
        SDL_RWops* small_font_mem = SDL_RWFromConstMem(EMBEDDED_FONT_ARRAY, EMBEDDED_FONT_LEN);
        small_font = TTF_OpenFontRW(small_font_mem, 1, 18);
    }
    if (!small_font) { fprintf(stderr, "Failed to load small font: %s\n", TTF_GetError()); /* continue anyway */ }


    SDL_AudioSpec want, have;
    SDL_memset(&want, 0, sizeof(want));
    want.freq = AUDIO_FREQ;
    want.format = AUDIO_S16SYS;
    want.channels = 1;
    want.samples = AUDIO_SAMPLES;
    want.callback = audio_callback;
    if (SDL_OpenAudio(&want, &have) < 0) {
        fprintf(stderr, "Failed to open audio: %s\n", SDL_GetError());
    } else {
        SDL_PauseAudio(0);
    }

    pthread_t network_thread;
    pthread_mutex_init(&dataMutex, NULL);
    pthread_create(&network_thread, NULL, fetchDataTask, NULL);

    radarRangeKm = rangeSteps[rangeStepIndex];
    sweepSpeed = sweepSpeedSteps[sweepSpeedIndex];
    
    Uint32 lastFrameTime = SDL_GetTicks();

    // Main Loop
    while (app_is_running) {
        Uint32 currentTime = SDL_GetTicks();
        float deltaTime = (currentTime - lastFrameTime) / 1000.0f;
        lastFrameTime = currentTime;

        // Event Handling
        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) {
                app_is_running = false;
            }
            if (event.type == SDL_KEYDOWN) {
                switch (event.key.keysym.sym) {
                    case SDLK_q: app_is_running = false; break;
                    case SDLK_m: 
                        currentMode = (currentMode == VOLUME) ? SPEED : VOLUME;
                        snprintf(displayMessage, sizeof(displayMessage), "Mode: %s", currentMode == VOLUME ? "Volume" : "Sweep Speed");
                        displayAlert = false;
                        displayTimeout = currentTime + DISPLAY_TIMEOUT_MS;
                        break;
                    case SDLK_EQUALS:
                    case SDLK_PLUS:
                        if (currentMode == VOLUME) {
                            if (beepVolume < 20) beepVolume++;
                            snprintf(displayMessage, sizeof(displayMessage), "Volume: %d", beepVolume);
                            displayAlert = false;
                        } else {
                            if (sweepSpeedIndex < speedStepsCount - 1) sweepSpeedIndex++;
                            sweepSpeed = sweepSpeedSteps[sweepSpeedIndex];
                            snprintf(displayMessage, sizeof(displayMessage), "Speed: %.0f d/s", sweepSpeed);
                            displayAlert = false;
                        }
                        displayTimeout = currentTime + DISPLAY_TIMEOUT_MS;
                        break;
                    case SDLK_MINUS:
                        if (currentMode == VOLUME) {
                            if (beepVolume > 0) beepVolume--;
                            snprintf(displayMessage, sizeof(displayMessage), "Volume: %d", beepVolume);
                            displayAlert = false;
                        } else {
                            if (sweepSpeedIndex > 0) sweepSpeedIndex--;
                            sweepSpeed = sweepSpeedSteps[sweepSpeedIndex];
                            snprintf(displayMessage, sizeof(displayMessage), "Speed: %.0f d/s", sweepSpeed);
                            displayAlert = false;
                        }
                        displayTimeout = currentTime + DISPLAY_TIMEOUT_MS;
                        break;
                    case SDLK_UP:
                        if(rangeStepIndex < rangeStepsCount - 1) rangeStepIndex++;
                        radarRangeKm = rangeSteps[rangeStepIndex];
                        snprintf(displayMessage, sizeof(displayMessage), "Range: %.0f km", radarRangeKm);
                        displayAlert = false;
                        free(activeBlips);
                        activeBlips = NULL;
                        activeBlipsCount = 0;
                        lastPingedAircraft.isValid = false;
                        if (paintedThisTurn) memset(paintedThisTurn, 0, trackedAircraftCount * sizeof(bool));
                        displayTimeout = currentTime + DISPLAY_TIMEOUT_MS;
                        break;
                    case SDLK_DOWN:
                        if(rangeStepIndex > 0) rangeStepIndex--;
                        radarRangeKm = rangeSteps[rangeStepIndex];
                        snprintf(displayMessage, sizeof(displayMessage), "Range: %.0f km", radarRangeKm);
                        displayAlert = false;
                        free(activeBlips);
                        activeBlips = NULL;
                        activeBlipsCount = 0;
                        lastPingedAircraft.isValid = false;
                        if (paintedThisTurn) memset(paintedThisTurn, 0, trackedAircraftCount * sizeof(bool));
                        displayTimeout = currentTime + DISPLAY_TIMEOUT_MS;
                        break;
                    case SDLK_LEFT:
                        if (inboundAlertDistanceKm > 1.0f) inboundAlertDistanceKm -= 1.0f;
                        snprintf(displayMessage, sizeof(displayMessage), "Alert: %.0f km", inboundAlertDistanceKm);
                        displayAlert = false;
                        displayTimeout = currentTime + DISPLAY_TIMEOUT_MS;
                        break;
                    case SDLK_RIGHT:
                        inboundAlertDistanceKm += 1.0f;
                        snprintf(displayMessage, sizeof(displayMessage), "Alert: %.0f km", inboundAlertDistanceKm);
                        displayAlert = false;
                        displayTimeout = currentTime + DISPLAY_TIMEOUT_MS;
                        break;
                }
            }
        }

        // Update
        lastSweepAngle = sweepAngle;
        sweepAngle += sweepSpeed * deltaTime;
        bool sweepWrapped = false;
        if (sweepAngle >= 360.0f) {
            sweepAngle = fmod(sweepAngle, 360.0f);
            sweepWrapped = true;
        }
        float rotationPeriodMs = (360.0f / sweepSpeed) * 1000.0f;

        pthread_mutex_lock(&dataMutex);
        if (sweepWrapped && paintedThisTurn) {
             memset(paintedThisTurn, 0, trackedAircraftCount * sizeof(bool));
        }

        // Detect inbound aircraft and build alert message
        int inboundCount = 0;
        char inboundMessage[100] = "";
        for (int i = 0; i < trackedAircraftCount; i++) {
            trackedAircraft[i].inbound = false;
            double headingToBase = fmod(trackedAircraft[i].bearing + 180.0, 360.0);
            double diff = fabs(headingToBase - trackedAircraft[i].heading);
            diff = fmod(diff + 360.0, 360.0);
            if (diff > 180.0) diff = 360.0 - diff;
            double distanceAlong = trackedAircraft[i].distanceKm * cos(deg2rad(diff));
            if (distanceAlong > 0) {
                double minDist = trackedAircraft[i].distanceKm * sin(deg2rad(diff));
                if (minDist <= inboundAlertDistanceKm) {
                    trackedAircraft[i].inbound = true;
                    const char* name = strlen(trackedAircraft[i].flight) > 0 ?
                                      trackedAircraft[i].flight : trackedAircraft[i].hex;
                    if (inboundCount == 0) {
                        snprintf(inboundMessage, sizeof(inboundMessage),
                                 "Inbound alert: %s", name);
                    } else {
                        size_t len = strlen(inboundMessage);
                        snprintf(inboundMessage + len, sizeof(inboundMessage) - len,
                                 ", %s", name);
                    }
                    inboundCount++;
                }
            }
        }
        if (inboundCount > 0) {
            strncpy(displayMessage, inboundMessage, sizeof(displayMessage));
            displayMessage[sizeof(displayMessage) - 1] = '\0';
            displayAlert = true;
            displayTimeout = currentTime + DISPLAY_TIMEOUT_MS;
        } else {
            displayAlert = false;
        }

        // Add radar blips for newly pinged aircraft
        for (int i = 0; i < trackedAircraftCount; i++) {
            if(paintedThisTurn && !paintedThisTurn[i]) {
                double targetBearing = trackedAircraft[i].bearing;
                bool bearingCrossed = (lastSweepAngle < targetBearing && sweepAngle >= targetBearing) ||
                                      (sweepWrapped && (targetBearing > lastSweepAngle || targetBearing <= sweepAngle));

                if(bearingCrossed) {
                    double angleRad = deg2rad(targetBearing);
                    float screenRadius = (trackedAircraft[i].distanceKm / radarRangeKm) * RADAR_RADIUS;

                    RadarBlip* newBlips = realloc(activeBlips, (activeBlipsCount + 1) * sizeof(RadarBlip));
                    if (newBlips) {
                        activeBlips = newBlips;
                        activeBlips[activeBlipsCount].x = RADAR_CENTER_X + screenRadius * sin(angleRad);
                        activeBlips[activeBlipsCount].y = RADAR_CENTER_Y - screenRadius * cos(angleRad);
                        activeBlips[activeBlipsCount].spawnTime = currentTime;
                        activeBlips[activeBlipsCount].bearing = trackedAircraft[i].heading;
                        activeBlips[activeBlipsCount].inbound = trackedAircraft[i].inbound;
                        activeBlips[activeBlipsCount].minutesToBase = -1;
                        if (trackedAircraft[i].inbound && trackedAircraft[i].groundSpeed > 0) {
                            double headingToBase = fmod(trackedAircraft[i].bearing + 180.0, 360.0);
                            double diff = fabs(headingToBase - trackedAircraft[i].heading);
                            diff = fmod(diff + 360.0, 360.0);
                            if (diff > 180.0) diff = 360.0 - diff;
                            double distanceAlong = trackedAircraft[i].distanceKm * cos(deg2rad(diff));
                            double speedKmh = trackedAircraft[i].groundSpeed * 1.852;
                            if (distanceAlong > 0 && speedKmh > 0) {
                                activeBlips[activeBlipsCount].minutesToBase = (int)round((distanceAlong / speedKmh) * 60.0);
                            }
                        }
                        activeBlipsCount++;

                        lastPingedAircraft = trackedAircraft[i];
                        paintedThisTurn[i] = true;
                        playBeep(getBeepFrequencyForAltitude(trackedAircraft[i].altitude), 50);
                    }
                }
            }
        }
        pthread_mutex_unlock(&dataMutex);

        // Update blips (in-place filtering)
        int aliveBlips = 0;
        for (int i = 0; i < activeBlipsCount; i++) {
            if (currentTime - activeBlips[i].spawnTime < rotationPeriodMs) {
                if (i != aliveBlips) {
                    activeBlips[aliveBlips] = activeBlips[i];
                }
                aliveBlips++;
            }
        }
        activeBlipsCount = aliveBlips;


        // Render
        SDL_SetRenderDrawColor(renderer, COLOR_BG.r, COLOR_BG.g, COLOR_BG.b, COLOR_BG.a);
        SDL_RenderClear(renderer);
        SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);

        // UI Text
        char buffer[100];
        int text_y = 20;
        SDL_Color textColor = COLOR_TEXT;
        SDL_Color accent = COLOR_RADAR;
        SDL_Color alert = COLOR_ALERT;

        if (displayAlert && currentTime < displayTimeout) {
            drawText(renderer, font, displayMessage, 20, text_y, alert, false);
            text_y += 35;
        }

        if (lastPingedAircraft.isValid) {
            snprintf(buffer, sizeof(buffer), "Flt: %s", strlen(lastPingedAircraft.flight) > 0 ? lastPingedAircraft.flight : "------");
            drawText(renderer, font, buffer, 20, text_y, textColor, false); text_y += 35;
            snprintf(buffer, sizeof(buffer), "Dst: %.1f km", lastPingedAircraft.distanceKm);
            drawText(renderer, font, buffer, 20, text_y, textColor, false); text_y += 35;
            if (lastPingedAircraft.altitude > 0) snprintf(buffer, sizeof(buffer), "Alt: %d ft", lastPingedAircraft.altitude);
            else snprintf(buffer, sizeof(buffer), "Alt: -----");
            drawText(renderer, font, buffer, 20, text_y, textColor, false); text_y += 35;
            if (lastPingedAircraft.groundSpeed > 0) snprintf(buffer, sizeof(buffer), "Spd: %.0f kt", lastPingedAircraft.groundSpeed);
            else snprintf(buffer, sizeof(buffer), "Spd: ---");
            drawText(renderer, font, buffer, 20, text_y, textColor, false); text_y += 35;
        } else {
             drawText(renderer, font, "Scanning...", 20, text_y, textColor, false); text_y += 35;
        }
        
        text_y = SCREEN_HEIGHT - 155;
        snprintf(buffer, sizeof(buffer), "Range: %.0f km", radarRangeKm);
        drawText(renderer, font, buffer, 20, text_y, accent, false); text_y += 35;
        snprintf(buffer, sizeof(buffer), "Alert: %.0f km", inboundAlertDistanceKm);
        drawText(renderer, font, buffer, 20, text_y, accent, false); text_y += 35;
        snprintf(buffer, sizeof(buffer), "Tracked: %d", trackedAircraftCount);
        drawText(renderer, font, buffer, 20, text_y, accent, false); text_y += 35;
        drawText(renderer, font, dataConnectionOk ? "Link: OK" : "Link: DOWN", 20, text_y, dataConnectionOk ? accent : alert, false);

        // Radar Display
        SDL_SetRenderDrawColor(renderer, accent.r, accent.g, accent.b, accent.a);
        for(int w = 0; w < 3; w++) {
            SDL_RenderDrawCircle(renderer, RADAR_CENTER_X, RADAR_CENTER_Y, RADAR_RADIUS - w);
        }
        drawDottedCircle(renderer, RADAR_CENTER_X, RADAR_CENTER_Y, RADAR_RADIUS * 2 / 3);
        drawDottedCircle(renderer, RADAR_CENTER_X, RADAR_CENTER_Y, RADAR_RADIUS * 1 / 3);
        // Cardinal crosshair lines
        SDL_RenderDrawLine(renderer, RADAR_CENTER_X - RADAR_RADIUS, RADAR_CENTER_Y,
                           RADAR_CENTER_X + RADAR_RADIUS, RADAR_CENTER_Y);
        SDL_RenderDrawLine(renderer, RADAR_CENTER_X, RADAR_CENTER_Y - RADAR_RADIUS,
                           RADAR_CENTER_X, RADAR_CENTER_Y + RADAR_RADIUS);
        drawText(renderer, small_font, "N", RADAR_CENTER_X, RADAR_CENTER_Y - RADAR_RADIUS - 10, accent, true);

        // Radar Sweep
        double sweepRad = deg2rad(sweepAngle);
        SDL_RenderDrawLine(renderer, RADAR_CENTER_X, RADAR_CENTER_Y, 
            RADAR_CENTER_X + (RADAR_RADIUS - 2) * sin(sweepRad), 
            RADAR_CENTER_Y - (RADAR_RADIUS - 2) * cos(sweepRad));

        // Blips
        for (int i = 0; i < activeBlipsCount; i++) {
            float age = currentTime - activeBlips[i].spawnTime;
            float fade = 1.0f - (age / rotationPeriodMs);
            if (fade < 0.0f) fade = 0.0f;
            float alpha = fade;
            if (activeBlips[i].inbound) {
                float flash = ((currentTime / 250) % 2) ? 1.0f : 0.2f;
                alpha *= flash;
            }
            Uint8 alphaByte = (Uint8)(alpha * 255);
            drawPlaneIcon(renderer,
                          activeBlips[i].x,
                          activeBlips[i].y,
                          activeBlips[i].bearing,
                          alphaByte);
            if (activeBlips[i].inbound && activeBlips[i].minutesToBase >= 0) {
                char tbuf[12];
                snprintf(tbuf, sizeof(tbuf), "%d", activeBlips[i].minutesToBase);
                SDL_Color minuteColor = accent;
                minuteColor.a = alphaByte;
                drawText(renderer, small_font, tbuf,
                         activeBlips[i].x + 10,
                         activeBlips[i].y - 10,
                         minuteColor, false);
            }
        }
        SDL_SetRenderDrawColor(renderer, accent.r, accent.g, accent.b, accent.a);

        // Display Overlay
        if (currentTime < displayTimeout && !displayAlert) {
            SDL_Rect bg = {SCREEN_WIDTH/2 - 175, SCREEN_HEIGHT/2 - 40, 350, 80};
            SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
            SDL_SetRenderDrawColor(renderer, COLOR_OVERLAY_BG.r, COLOR_OVERLAY_BG.g, COLOR_OVERLAY_BG.b, COLOR_OVERLAY_BG.a);
            SDL_RenderFillRect(renderer, &bg);
            SDL_SetRenderDrawColor(renderer, accent.r, accent.g, accent.b, accent.a);
            SDL_RenderDrawRect(renderer, &bg);
            drawText(renderer, font, displayMessage, SCREEN_WIDTH/2, bg.y + 25, textColor, true);
        }

        SDL_RenderPresent(renderer);
    }

    // Cleanup
    app_is_running = false;
    pthread_join(network_thread, NULL);
    pthread_mutex_destroy(&dataMutex);
    
    free(trackedAircraft);
    free(activeBlips);
    free(paintedThisTurn);
    
    SDL_CloseAudio();
    if(font) TTF_CloseFont(font);
    if(small_font) TTF_CloseFont(small_font);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    IMG_Quit();
    TTF_Quit();
    SDL_Quit();

    return 0;
}

// Helper function to draw an unfilled circle using Bresenham's algorithm
void SDL_RenderDrawCircle(SDL_Renderer * renderer, int32_t centreX, int32_t centreY, int32_t radius) {
   const int32_t diameter = (radius * 2);
   int32_t x = (radius - 1);
   int32_t y = 0;
   int32_t tx = 1;
   int32_t ty = 1;
   int32_t error = (tx - diameter);
   while (x >= y) {
      SDL_RenderDrawPoint(renderer, centreX + x, centreY - y);
      SDL_RenderDrawPoint(renderer, centreX + x, centreY + y);
      SDL_RenderDrawPoint(renderer, centreX - x, centreY - y);
      SDL_RenderDrawPoint(renderer, centreX - x, centreY + y);
      SDL_RenderDrawPoint(renderer, centreX + y, centreY - x);
      SDL_RenderDrawPoint(renderer, centreX + y, centreY + x);
      SDL_RenderDrawPoint(renderer, centreX - y, centreY - x);
      SDL_RenderDrawPoint(renderer, centreX - y, centreY + x);
      if (error <= 0) { ++y; error += ty; ty += 2; }
      if (error > 0) { --x; tx += 2; error += (tx - diameter); }
   }
}

void drawDottedCircle(SDL_Renderer *renderer, int32_t centreX, int32_t centreY, int32_t radius) {
    for (int i = 0; i < 360; i += 15) {
        double angleRad = deg2rad(i);
        int16_t x = centreX + radius * sin(angleRad);
        int16_t y = centreY - radius * cos(angleRad);
        SDL_RenderDrawPoint(renderer, x, y);
    }
}

void drawText(SDL_Renderer* renderer, TTF_Font* font, const char* text, int x, int y, SDL_Color color, bool center) {
    if (!text || !font) return;
    SDL_Surface* surface = TTF_RenderText_Blended(font, text, color);
    if (!surface) return;
    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
    if (!texture) { SDL_FreeSurface(surface); return; }

    SDL_SetTextureBlendMode(texture, SDL_BLENDMODE_BLEND);
    SDL_SetTextureAlphaMod(texture, color.a);
    
    SDL_Rect destRect = {x, y, surface->w, surface->h};
    if (center) {
        destRect.x = x - surface->w / 2;
        destRect.y = y - surface->h / 2;
    }

    SDL_RenderCopy(renderer, texture, NULL, &destRect);
    SDL_FreeSurface(surface);
    SDL_DestroyTexture(texture);
}

void drawPlaneIcon(SDL_Renderer* renderer, int x, int y, double angle, Uint8 alpha) {
    static SDL_Texture* planeTexture = NULL;
    static int planeWidth = 0;
    static int planeHeight = 0;

    if (!planeTexture) {
        SDL_Surface* surface = IMG_Load("plane.png");
        if (!surface) {
            return;
        }

        planeWidth = (int)(surface->w * PLANE_ICON_SCALE);
        planeHeight = (int)(surface->h * PLANE_ICON_SCALE);

        planeTexture = SDL_CreateTextureFromSurface(renderer, surface);
        SDL_FreeSurface(surface);
        if (!planeTexture) {
            return;
        }
        SDL_SetTextureBlendMode(planeTexture, SDL_BLENDMODE_BLEND);
    }

    SDL_SetTextureAlphaMod(planeTexture, alpha);

    SDL_Rect dst = {
        x - planeWidth / 2,
        y - planeHeight / 2,
        planeWidth,
        planeHeight
    };

    SDL_RenderCopyEx(renderer, planeTexture, NULL, &dst, angle, NULL, SDL_FLIP_NONE);
}

double deg2rad(double deg) { return deg * M_PI / 180.0; }
double haversine(double lat1, double lon1, double lat2, double lon2) {
    double dLat = deg2rad(lat2 - lat1);
    double dLon = deg2rad(lon2 - lon1);
    double a = sin(dLat / 2) * sin(dLat / 2) + cos(deg2rad(lat1)) * cos(deg2rad(lat2)) * sin(dLon / 2) * sin(dLon / 2);
    double c = 2 * atan2(sqrt(a), sqrt(1 - a));
    return EARTH_RADIUS_KM * c;
}
double calculateBearing(double lat1, double lon1, double lat2, double lon2) {
    double lonDiff = deg2rad(lon2 - lon1);
    lat1 = deg2rad(lat1); lat2 = deg2rad(lat2);
    double y = sin(lonDiff) * cos(lat2);
    double x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(lonDiff);
    double bearing = atan2(y, x);
    bearing = fmod((bearing * 180.0 / M_PI + 360.0), 360.0);
    return bearing;
}

