<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>radar1090 // AI ENHANCED</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css" />
  
  <style>
    /* Interaction Overlay */
    #interaction-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(5, 5, 5, 0.95); z-index: 9999;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      cursor: pointer; backdrop-filter: blur(5px);
    }
    #start-btn {
      border: 2px solid #00ff41; color: #00ff41; background: transparent;
      padding: 20px 40px; font-family: 'Share Tech Mono', monospace;
      font-size: 24px; letter-spacing: 4px; text-transform: uppercase;
      box-shadow: 0 0 20px rgba(0, 255, 65, 0.2); animation: pulse 2s infinite;
    }
    @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; text-shadow: 0 0 10px #00ff41; } 100% { opacity: 0.8; } }
    
    /* --- CUSTOM AI CONTROL STYLES --- */
    .control-row.ai-status-row { display: flex; align-items: center; gap: 10px; }
    .control-value.status-text { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; width: 100%; font-size: 0.85em; line-height: 1.2; color: #00ff41; }
    .ai-custom-block { border-bottom: 1px solid #333; padding: 10px 0; margin-bottom: 5px; display: block; }
    .ai-label { display: block; font-family: 'Share Tech Mono', monospace; color: #aaa; font-size: 14px; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
    .control-select { background: #111; color: #00ff41; border: 1px solid #444; font-family: 'Share Tech Mono', monospace; padding: 10px; width: 100%; text-transform: uppercase; font-size: 14px; cursor: pointer; border-radius: 4px; box-sizing: border-box; appearance: none; background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%2300ff41%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E"); background-repeat: no-repeat; background-position: right 12px top 50%; background-size: 10px auto; }
    .control-select:focus { outline: 1px solid #00ff41; background-color: #000; }
    .ai-status-row .control-button { min-width: 80px; }
    
    #weather-display { color: #a5d6ff; border-left: 3px solid #00ff41; padding-left: 8px; margin-bottom: 10px; }
    #voice-visualizer { width: 100%; height: 4px; background: #111; margin-top: 5px; position: relative; overflow: hidden; }
    #voice-bar { width: 0%; height: 100%; background: #00ff41; box-shadow: 0 0 10px #00ff41; transition: width 0.05s ease-out; }

    body.emergency-active::before { content: ""; position: fixed; top:0; left:0; right:0; bottom:0; border: 4px solid red; pointer-events: none; z-index: 9998; animation: emergencyFlash 1s infinite; }
    @keyframes emergencyFlash { 0%, 100% { opacity: 0; } 50% { opacity: 1; } }

    .log-modal-content { background: #0a0a0a; border: 1px solid #00ff41; color: #eee; font-family: 'Share Tech Mono', monospace; max-height: 60vh; overflow-y: auto; padding: 20px; }
    .log-entry { border-bottom: 1px solid #333; padding: 8px 0; font-size: 12px; }
    .log-entry.alert { color: #ff5555; }
    .log-entry.debug { color: #9ec5ff; }
    .log-timestamp { color: #666; margin-right: 10px; }
  </style>
</head>
<body>

  <!-- INITIALIZATION OVERLAY -->
  <div id="interaction-overlay" onclick="startSystem()">
    <div id="start-btn">INITIALIZE RADAR</div>
    <div style="margin-top: 20px; color: #888; font-family: monospace;">CLICK TO ACTIVATE AI & AUDIO LINKS</div>
  </div>

  <main class="app">
    <div class="panel-toggle-bar" role="group" aria-label="Layout controls">
      <button type="button" class="control-button panel-toggle-button" id="controls-panel-toggle" aria-controls="controls-panel" aria-expanded="true" aria-pressed="true">Hide Controls</button>
      <button type="button" class="control-button panel-toggle-button" id="data-panel-toggle" aria-controls="data-panel" aria-expanded="true" aria-pressed="true">Hide Data</button>
    </div>

    <section class="sidebar controls-panel" id="controls-panel">
      <h1>radar1090 <span style="font-size:0.5em; color:#00ff41;">AI</span></h1>
      <div class="status" id="status"></div>
      <section class="controls">
        <h2>Controls</h2>
        <div class="control-panel">
          
          <!-- AI CONTROLS -->
          <div class="control-row ai-status-row">
            <div class="control-info">
              <span class="control-name" style="color:#00ff41">AI Core</span>
              <span class="control-value status-text" id="ai-status-text" title="Status">OFFLINE</span>
            </div>
            <div class="control-buttons">
              <button type="button" class="control-button" id="ai-toggle-btn">RETRY</button>
            </div>
          </div>

          <div class="ai-custom-block">
             <span class="ai-label">AI Persona Profile</span>
             <select id="ai-persona-select" class="control-select">
                <option value="MILITARY">Tactical Defense</option>
                <option value="ATC">Air Traffic Control</option>
                <option value="SPOTTER">Plane Spotter</option>
             </select>
          </div>

          <div class="control-row">
            <div class="control-info">
              <span class="control-name">Commentary</span>
              <span class="control-value" id="tts-status">ACTIVE</span>
              <div id="voice-visualizer"><div id="voice-bar"></div></div>
            </div>
            <div class="control-buttons">
               <button type="button" class="control-button" id="tts-mute-toggle">MUTE</button>
            </div>
          </div>
          
          <div class="control-row control-row--single">
             <div class="control-buttons">
               <button type="button" class="control-button" id="ai-self-test-btn">RUN AI SELF-TEST</button>
                <button type="button" class="control-button" id="show-log-btn">VIEW COMMS LOG</button>
             </div>
          </div>
          
          <!-- ORIGINAL CONTROLS -->
          <div class="control-row">
            <div class="control-info">
              <span class="control-name" id="volume-label">Volume</span>
              <span class="control-value" id="volume-value">10</span>
            </div>
            <div class="control-buttons">
              <button type="button" class="control-button control-button--square" id="volume-decrease" aria-label="Decrease volume">&minus;</button>
              <button type="button" class="control-button control-button--square" id="volume-increase" aria-label="Increase volume">+</button>
            </div>
          </div>

          <div class="control-row">
            <div class="control-info">
              <span class="control-name">Radar Range</span>
              <span class="control-value" id="range-value">50 km</span>
            </div>
            <div class="control-buttons">
              <button type="button" class="control-button control-button--square" id="range-decrease" aria-label="Decrease range">&minus;</button>
              <button type="button" class="control-button control-button--square" id="range-increase" aria-label="Increase range">+</button>
            </div>
          </div>

          <!-- Additional Controls (Base Alert, Rotate, Location, Labels, OSM) Preserved below -->
          <div class="control-row">
            <div class="control-info"><span class="control-name">Base Alert Range</span><span class="control-value" id="alert-range-value">15 km</span></div>
            <div class="control-buttons">
              <button type="button" class="control-button control-button--square" id="alert-range-decrease">&minus;</button>
              <button type="button" class="control-button control-button--square" id="alert-range-increase">+</button>
            </div>
          </div>
          <div class="control-row">
            <div class="control-info"><span class="control-name">Rotate Radar</span></div>
            <div class="control-buttons"><button type="button" class="control-button" id="radar-rotate">Rotate</button></div>
          </div>
          <div class="control-row control-row--single">
            <div class="control-buttons"><button type="button" class="control-button" id="center-on-location">Use My Location</button></div>
          </div>
          <div class="control-row control-row--single">
            <div class="control-buttons"><button type="button" class="control-button" id="manual-location">Set Location Manually</button></div>
          </div>
          <div class="control-row">
            <div class="control-info"><span class="control-name">Aircraft Labels</span><span class="control-value" id="aircraft-details-state">Hidden</span></div>
            <div class="control-buttons"><button type="button" class="control-button" id="aircraft-details-toggle">Show</button></div>
          </div>
          <div class="control-row">
            <div class="control-info"><span class="control-name">OpenStreetMap Overlay</span><span class="control-value" id="openstreetmap-overlay-state">Hidden</span></div>
            <div class="control-buttons"><button type="button" class="control-button" id="openstreetmap-overlay-toggle">Show</button></div>
          </div>

        </div>
      </section>
      
      <section class="audio">
        <h2>Live Audio</h2>
        <p class="hint">The local airband feed plays automatically—use mute if you need quiet.</p>
        <div class="audio-actions">
          <button type="button" class="control-button" id="audio-mute-toggle" aria-pressed="false" aria-label="Toggle audio mute">Mute</button>
          <span class="audio-status" id="audio-status">Connecting…</span>
        </div>
        <audio id="airband-stream" preload="none" autoplay muted playsinline></audio>
      </section>
    </section>

    <section class="radar-container">
      <div class="version-chip" id="version" aria-label="Application version"></div>
      <div class="openstreetmap-overlay" id="openstreetmap-overlay" hidden aria-hidden="true">
        <iframe id="openstreetmap-frame" title="OpenStreetMap overlay" loading="lazy" referrerpolicy="no-referrer-when-downgrade" allowfullscreen></iframe>
      </div>
      <canvas id="radar" width="960" height="640" aria-label="Radar display"></canvas>
    </section>

    <section class="sidebar data-panel" id="data-panel">
      <h2>Live Data</h2>
      <div class="info-stack">
        <div class="info-block" id="weather-display">Weather Data Pending...</div>
        <div class="info-block" id="aircraft-info"></div>
        <div class="info-block" id="range-info"></div>
        <div class="info-block" id="receiver-info" aria-live="polite"></div>
      </div>
      <div class="message-ticker" id="message-ticker" aria-live="polite">
        <span class="message-ticker__track" id="message-ticker-track"></span>
      </div>
      <div class="message" id="message"></div>
    </section>
  </main>

  <!-- MODALS -->
  <div class="modal" id="geolocation-permission-modal" hidden aria-hidden="true">
    <div class="modal__backdrop" id="geolocation-permission-backdrop"></div>
    <section class="modal__dialog" role="dialog"><h2 id="geolocation-permission-title">Enable location access</h2><div class="modal__actions"><button type="button" class="control-button primary" id="geolocation-permission-close">Got it</button></div></section>
  </div>
  <div class="modal" id="manual-location-modal" hidden aria-hidden="true">
    <div class="modal__backdrop" id="manual-location-backdrop"></div>
    <section class="modal__dialog modal__dialog--wide manual-location-modal" role="dialog">
      <h2 id="manual-location-title">Set receiver location</h2>
      <div class="manual-location__map" id="manual-location-map"></div>
      <p class="manual-location__coordinates" id="manual-location-coordinates"></p>
      <div class="modal__actions">
        <button type="button" class="control-button" id="manual-location-cancel">Cancel</button>
        <button type="button" class="control-button primary" id="manual-location-confirm" disabled>Use This Location</button>
      </div>
    </section>
  </div>
  <!-- LOG MODAL -->
  <div class="modal" id="ai-log-modal" hidden aria-hidden="true">
    <div class="modal__backdrop" id="ai-log-backdrop"></div>
    <section class="modal__dialog" role="dialog" aria-modal="true">
      <h2>Tactical Comms Log</h2>
      <div id="ai-log-content" class="log-modal-content"></div>
      <div class="modal__actions"><button type="button" class="control-button" id="ai-log-close">Close</button></div>
    </section>
  </div>

  <script type="module" src="app.js"></script>

  <!-- 4. AI CONTROLLER SCRIPT -->
  <script>
    function normalizeOllamaBase(url) {
        if (!url) return url;
        try {
            const parsed = new URL(url);
            parsed.pathname = parsed.pathname.replace(/\/+$/, '');
            return parsed.toString().replace(/\/+$/, '');
        } catch (e) {
            return url.replace(/\/+$/, '');
        }
    }

    function resolveOllamaCandidates() {
        const saved = localStorage.getItem('ollamaUrl');
        const protocol = window.location.protocol.startsWith('http') ? window.location.protocol : 'http:';
        const host = window.location.hostname || '127.0.0.1';
        const primary = `${protocol}//${host}:11434`;
        const originProxy = `${window.location.origin}/ollama`;
        const originProxySlash = `${window.location.origin}/ollama/`;

        // If the dashboard is served via HTTPS but Ollama is only available over HTTP,
        // try the downgraded scheme as a fallback so LAN users still connect.
        const candidates = saved ? [saved] : [primary];
        if (!saved && protocol === 'https:') {
            candidates.push(`http://${host}:11434`);
        }

        // If lighttpd or another reverse proxy exposes Ollama on the same origin
        // (e.g., via "/ollama"), try that path to avoid mixed-content or CORS blocks.
        candidates.push(originProxy, originProxySlash);

        return [...new Set(candidates.map(normalizeOllamaBase))];
    }

    async function fetchWithTimeout(resource, options = {}, timeoutMs = 8000, label = 'fetch') {
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), timeoutMs);
        const started = performance.now();
        const isMixedContentRisk = window.location.protocol === 'https:' && resource.startsWith('http:');

        if (isMixedContentRisk) {
            aiLog('DEBUG', `Mixed-content risk: page is https but request is http -> ${resource}`, 'debug');
        }

        aiLog('DEBUG', `Requesting ${label} -> ${resource} (timeout ${timeoutMs}ms)`, 'debug');
        try {
            const response = await fetch(resource, { ...options, signal: controller.signal });
            const elapsed = Math.round(performance.now() - started);
            aiLog('DEBUG', `Response ${label}: status ${response.status} in ${elapsed}ms`, 'debug');
            return response;
        } catch (e) {
            const elapsed = Math.round(performance.now() - started);
            const hints = [];

            if (e.name === 'AbortError') {
                hints.push('request timed out');
            }

            if (isMixedContentRisk) {
                hints.push('browser may block HTTP calls from HTTPS pages');
            }

            if (e instanceof TypeError && resource.startsWith('http')) {
                hints.push('check CORS headers or reverse proxy to same origin');
                if (resource.includes(':11434')) {
                    hints.push('if Ollama is running, add Access-Control-Allow-Origin:* (or set up /ollama proxy) so browsers can reach it');
                }
            }

            const hintText = hints.length ? ` Hint: ${hints.join('; ')}.` : '';
            aiLog('AI ERROR', `${label} failed after ${elapsed}ms: ${e.message || e}.${hintText}`, 'alert');
            throw e;
        } finally {
            clearTimeout(timer);
        }
    }

    const ollamaCandidates = resolveOllamaCandidates();

    const AI_CONFIG = {
        dump1090Base: "http://192.168.50.100:8080/dump1090-fa/data",
        ollamaUrl: ollamaCandidates[0],
        ollamaModel: null,
        myLat: 54.531836,
        myLon: -1.087954,
        locationName: "SECTOR",
        scanInterval: 20000,
        maxPlanes: 5,
        weatherData: null
    };

    const COMMENTARY_COOLDOWN_MS = 2 * 60 * 1000; // Enforce 2 minute spacing between spoken updates
    let lastCommentaryTimestamp = 0;

    // Slow hosts can take a while to load or answer Ollama requests; allow up to 120s.
    const OLLAMA_DISCOVERY_TIMEOUT_MS = 120000;
    const OLLAMA_SELF_TEST_TIMEOUT_MS = 120000;
    const OLLAMA_CHAT_TIMEOUT_MS = 120000;

    const voiceNameMatches = (voice, hints) => {
        const name = (voice.name || '').toLowerCase();
        return hints.some((hint) => name.includes(hint));
    };

    const PERSONAS = {
        MILITARY: `Role: forward air defense controller in an active war zone. Tone: clenched and urgent—assume every track could be hostile until cleared. Analyze behaviour for threat patterns (rapid climb/descents, formation spacing, racetrack or holding patterns, base approaches). Declare bogeys/bandits, call intent (hot/cold), and issue shoot/no-shoot vibes. Do NOT read out raw transponder stats; focus only on threat calls, intent, and manoeuvre analysis. Use clipped brevity ("bogey", "bandit", "hot", "cold", "spiked"), never polite, no hedging.`,
        ATC: `Role: {LOCATION} RADAR controller. Tone: calm, procedural. Provide one transmission to pilots: lead with conflicts/alerts, then ICAO-style traffic advisories with callout clock position, distance, altitude, and heading. Keep it standard phraseology, neutral delivery, no jokes, no questions.`,
        SPOTTER: `Role: over-caffeinated plane spotter livestreaming to friends. Tone: goofy git streamer—riff with memes, playful analogies, and self-aware jokes about liveries, types, or wild turns. Sound like you're narrating a chaotic Twitch chat. One hyped-up sentence only—no instructions or questions.`
    };

    const PERSONA_STYLE_HINTS = {
        MILITARY: 'War-zone sitrep. Rapid-fire, terse, brevity codes, threat priority, behaviour analysis.',
        ATC: 'Neutral ATC cadence. Standard phraseology, deconfliction first.',
        SPOTTER: 'Chaotic livestream hype. Jokes, memes, playful commentary.'
    };

    const FEMALE_VOICE_HINTS = ['female', 'woman', 'lady', 'fiona', 'olivia', 'emma', 'amy', 'serena', 'susan', 'victoria', 'kate', 'karen'];
    const MALE_VOICE_HINTS = ['male', 'man', 'guy', 'boy', 'david', 'daniel', 'liam', 'sean', 'declan', 'brian', 'paul', 'peter', 'michael', 'jack', 'ryan', 'george'];

    const PERSONA_VOICE_PREFERENCES = {
        MILITARY: [
            (v) => v.lang === 'en-US',
            (v) => v.lang && v.lang.startsWith('en-US')
        ],
        ATC: [
            (v) => v.lang === 'en-GB' && voiceNameMatches(v, FEMALE_VOICE_HINTS),
            (v) => v.lang && v.lang.startsWith('en-GB') && voiceNameMatches(v, FEMALE_VOICE_HINTS),
            (v) => v.lang && v.lang.startsWith('en-US') && voiceNameMatches(v, FEMALE_VOICE_HINTS),
            (v) => voiceNameMatches(v, FEMALE_VOICE_HINTS) && v.lang && v.lang.startsWith('en-'),
            (v) => v.lang === 'en-GB',
            (v) => (v.name || '').includes('UK English') || (v.name || '').includes('Daniel')
        ],
        SPOTTER: [
            (v) => v.lang === 'en-IE' && voiceNameMatches(v, MALE_VOICE_HINTS),
            (v) => v.lang && v.lang.startsWith('en-IE') && voiceNameMatches(v, MALE_VOICE_HINTS),
            (v) => v.lang && v.lang.startsWith('en-AU') && voiceNameMatches(v, MALE_VOICE_HINTS),
            (v) => v.lang && v.lang.startsWith('en-NZ') && voiceNameMatches(v, MALE_VOICE_HINTS),
            (v) => v.lang && v.lang.startsWith('en-CA') && voiceNameMatches(v, MALE_VOICE_HINTS),
            (v) => v.lang === 'en-IE',
            (v) => v.lang && v.lang.startsWith('en-AU'),
            (v) => v.lang && v.lang.startsWith('en-NZ'),
            (v) => v.lang && v.lang.startsWith('en-CA'),
            (v) => (v.name || '').toLowerCase().includes('irish'),
            (v) => voiceNameMatches(v, MALE_VOICE_HINTS)
        ]
    };

    const AIRCRAFT_TYPES = { "B738": "Boeing 737", "A320": "Airbus A320", "B77W": "Boeing 777", "B744": "Boeing 747", "A388": "Airbus A380", "C172": "Cessna 172", "B789": "Dreamliner", "A359": "Airbus A350", "H25B": "HondaJet", "F16": "F-16 Fighting Falcon", "F35": "F-35 Lightning", "EUFI": "Eurofighter" };

    let aiProcessing = false;
    let systemActive = false;
    let voiceEnabled = true;
    let currentUtterance = null;
    let isSpeaking = false;
    let audioContext = null; 
    let msgHistory = [];
    let visInterval = null;

    let carrierNode = null;
    let carrierGain = null;
    let monitorInterval = null;
    let lastAiStatus = { text: null, color: null };
    let serverDiagnosticsLogged = false;
    let proxyHintLogged = false;
    let corsEnvHintLogged = false;
    let corsForbiddenHintLogged = false;
    let remediationLogged = false;
    let lastProxy404Candidate = null;
    let lastCorsBlockedCandidate = null;
    let lastCorsForbiddenCandidate = null;
    let lastOpaqueCandidate = null;
    const corsProbeLogged = {};

    function logOllamaRemediation() {
        if (remediationLogged) return;
        remediationLogged = true;

        aiLog('DEBUG', 'Ollama remediation checklist:', 'debug');
        if (lastProxy404Candidate) {
            aiLog('DEBUG', ' - /ollama returned 404. Add a reverse-proxy rule to forward /ollama/* to 127.0.0.1:11434 (lighttpd example below).', 'debug');
            aiLog('DEBUG', '   $HTTP["url"].startswith("/ollama/") { proxy.server = ("" => (( "host" => "127.0.0.1", "port" => 11434 ))) }', 'debug');
        }
        if (lastCorsBlockedCandidate || lastOpaqueCandidate) {
            aiLog('DEBUG', ' - Direct port responded without CORS. Enable Access-Control-Allow-Origin on Ollama or access it via a same-origin /ollama proxy.', 'debug');
            aiLog('DEBUG', '   Example: export OLLAMA_ORIGINS="*" && export OLLAMA_HOST=0.0.0.0 && systemctl restart ollama', 'debug');
        }
        if (lastCorsForbiddenCandidate) {
            aiLog('DEBUG', ' - Ollama returned 403 Forbidden for browser Origin. Set OLLAMA_ORIGINS to your dashboard URL (or "*") and restart.', 'debug');
            const origin = window.location.origin;
            aiLog('DEBUG', `   export OLLAMA_ORIGINS="${origin}" && export OLLAMA_HOST=0.0.0.0 && systemctl restart ollama`, 'debug');
            aiLog('DEBUG', '   (systemd) sudo mkdir -p /etc/systemd/system/ollama.service.d', 'debug');
            aiLog('DEBUG', `   (systemd) printf "[Service]\nEnvironment=OLLAMA_ORIGINS=${origin}\nEnvironment=OLLAMA_HOST=0.0.0.0\n" | sudo tee /etc/systemd/system/ollama.service.d/override.conf`, 'debug');
            aiLog('DEBUG', '   (systemd) sudo systemctl daemon-reload && sudo systemctl restart ollama', 'debug');
        }

        const origin = window.location.origin;
        let proxyPath = '/ollama';
        if (lastProxy404Candidate) {
            try {
                proxyPath = new URL(lastProxy404Candidate).pathname.replace(/\/$/, '') || proxyPath;
            } catch (err) {
                console.debug('Unable to parse proxy path from candidate', err);
            }
        }
        aiLog('DEBUG', ` - Server-side checks: curl -i http://127.0.0.1:11434/api/tags ; curl -i -H "Origin: ${origin}" http://127.0.0.1:11434/api/tags ; curl -i http://127.0.0.1${proxyPath}/api/tags`, 'debug');
        aiLog('DEBUG', 'If the proxy curl returns 404, the rule is missing. If the Origin curl lacks Access-Control-Allow-Origin, enable CORS or proxy.', 'debug');
    }

    function startSystem() {
        document.getElementById('interaction-overlay').style.display = 'none';
        const radar = document.getElementById('radar');
        if(radar) radar.scrollIntoView({behavior: 'smooth', block: 'center', inline: 'center'});

        systemActive = true;
        window.speechSynthesis.resume(); // Force Audio Context Wakeup

        aiLog("DEBUG", `Startup: host=${window.location.hostname} protocol=${window.location.protocol} dump1090=${AI_CONFIG.dump1090Base} ollamaCandidates=${ollamaCandidates.join(', ')}`, 'debug');
        
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContext();
            if(audioContext.state === 'suspended') audioContext.resume();
        } catch(e) { console.warn("Web Audio API not supported"); }

        const savedPersona = getCookie("aiPersona");
        if(savedPersona && PERSONAS[savedPersona]) document.getElementById('ai-persona-select').value = savedPersona;

        updateReceiverLocation().then(() => {
            fetchLocalWeather();
            fetchLocationName(AI_CONFIG.myLat, AI_CONFIG.myLon).then(name => {
                AI_CONFIG.locationName = name;
            });

            updateAiStatus("INITIALIZING...", "#ffff00");
            
            // BOOT SEQUENCE: Start with a clear chime before the first broadcast
            setTimeout(() => {
                 speak("System Online. Sensors Calibrated.");
                 detectModel();
                 setInterval(runAiCycle, AI_CONFIG.scanInterval);
                 setInterval(fetchLocalWeather, 30 * 60 * 1000);
            }, 800);
        });
    }

    // --- AUDIO ENGINE ---
    function startCarrier() {
        if (!audioContext || !voiceEnabled) return;
        if (audioContext.state === 'suspended') audioContext.resume();
        // Background carrier removed for clean AI audio.
    }

    function stopCarrier() {
        if (!carrierNode || !carrierGain) return;
        try { carrierNode.stop(); } catch (e) { /* noop */ }
        try { carrierNode.disconnect(); carrierGain.disconnect(); } catch (e) { /* noop */ }
        carrierNode = null; carrierGain = null;
    }
    
    // --- CORE LOGIC ---
    function speak(text) {
        if (!voiceEnabled) return;
        startVisualizer();

        // Stop any existing speech first
        window.speechSynthesis.cancel();
        stopSpeechSequence();

        currentUtterance = new SpeechSynthesisUtterance(text);
        const persona = document.getElementById('ai-persona-select').value;
        currentUtterance.rate = persona === 'ATC' ? 0.95 : persona === 'SPOTTER' ? 1.18 : 1.1;
        currentUtterance.pitch = persona === 'ATC' ? 1.12 : persona === 'SPOTTER' ? 0.85 : 1.0;

        const voice = selectVoiceForPersona(persona);
        if (voice) currentUtterance.voice = voice;

        // START SEQUENCE
        startCarrier();
        isSpeaking = true;
        updateAiStatus("BROADCASTING...", "#00ff41");
        
        // WATCHDOG: Force stop if speech hangs
        let watchdog = setTimeout(() => {
            if(isSpeaking) {
                console.warn("AI Watchdog: Speech timed out.");
                stopSpeechSequence();
            }
        }, 15000); // 15s safety limit

        currentUtterance.onend = () => { 
            clearTimeout(watchdog);
            stopSpeechSequence();
        };
        
        // Small delay to ensure carrier is audible before voice
        setTimeout(() => window.speechSynthesis.speak(currentUtterance), 150);
    }
    
    function stopSpeechSequence() {
        isSpeaking = false;
        currentUtterance = null;
        updateAiStatus("ONLINE", "#00ff41");
        stopCarrier();
    }

    function selectVoiceForPersona(persona) {
        const voices = window.speechSynthesis.getVoices();
        const personaFallbacks = persona === 'SPOTTER'
            ? [
                (v) => v.lang === 'en-AU' && voiceNameMatches(v, MALE_VOICE_HINTS),
                (v) => v.lang === 'en-NZ' && voiceNameMatches(v, MALE_VOICE_HINTS),
                (v) => v.lang === 'en-CA' && voiceNameMatches(v, MALE_VOICE_HINTS),
                (v) => v.lang === 'en-GB' && voiceNameMatches(v, MALE_VOICE_HINTS)
            ]
            : [
                (v) => v.lang === 'en-GB' && voiceNameMatches(v, FEMALE_VOICE_HINTS),
                (v) => v.lang && v.lang.startsWith('en-US') && voiceNameMatches(v, FEMALE_VOICE_HINTS)
            ];

        const fallbacks = [
            (v) => v.lang === 'en-GB',
            (v) => (v.name || '').includes('UK English') || (v.name || '').includes('Daniel')
        ];

        const predicates = [
            ...(PERSONA_VOICE_PREFERENCES[persona] || []),
            ...personaFallbacks,
            ...fallbacks
        ];

        for (const predicate of predicates) {
            const match = voices.find(predicate);
            if (match) return match;
        }

        // As a final split, keep ATC and SPOTTER apart by gender hints even when only generic English voices exist.
        const englishVoices = voices.filter((v) => v.lang && v.lang.startsWith('en-'));
        if (persona === 'ATC') {
            const female = englishVoices.find((v) => voiceNameMatches(v, FEMALE_VOICE_HINTS));
            if (female) return female;
            const nonMale = englishVoices.find((v) => !voiceNameMatches(v, MALE_VOICE_HINTS));
            if (nonMale) return nonMale;
        } else if (persona === 'SPOTTER') {
            const male = englishVoices.find((v) => voiceNameMatches(v, MALE_VOICE_HINTS));
            if (male) return male;
            const nonFemale = englishVoices.find((v) => !voiceNameMatches(v, FEMALE_VOICE_HINTS));
            if (nonFemale) return nonFemale;
        }

        return englishVoices[0] || null;
    }

    window.speechSynthesis.onvoiceschanged = () => window.speechSynthesis.getVoices();

    // [Rest of helper functions: startVisualizer, detectModel, runAiCycle, etc. remain unchanged]
    // ... (Re-inserting existing helpers below for completeness)
    
    function startVisualizer() {
        if(visInterval) clearInterval(visInterval);
        const bar = document.getElementById('voice-bar');
        visInterval = setInterval(() => {
            if(isSpeaking) bar.style.width = Math.floor(Math.random() * 80 + 20) + "%";
            else bar.style.width = "0%";
        }, 100);
    }

    const logModal = document.getElementById('ai-log-modal');
    const logContent = document.getElementById('ai-log-content');
    document.getElementById('show-log-btn').addEventListener('click', () => {
        logContent.innerHTML = msgHistory.map(e =>
            `<div class="log-entry ${e.type}"><span class="log-timestamp">[${e.time}]</span><strong>${e.title}:</strong> ${e.text}</div>`
        ).join('');
        logModal.hidden = false;
    });
    document.getElementById('ai-self-test-btn').addEventListener('click', () => {
        runAiSelfTest().catch(e => aiLog('AI ERROR', `Self-test failed: ${e.message || e}`, 'alert'));
    });
    document.getElementById('ai-log-close').addEventListener('click', () => logModal.hidden = true);
    document.getElementById('ai-log-backdrop').addEventListener('click', () => logModal.hidden = true);

    async function fetchLocationName(lat, lon) {
        try {
            const r = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10`);
            const d = await r.json();
            const addr = d.address || {};
            return (addr.city || addr.town || addr.municipality || addr.county || "SECTOR").toUpperCase();
        } catch(e) { return "SECTOR"; }
    }

    async function fetchLocalWeather() {
        try {
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${AI_CONFIG.myLat}&longitude=${AI_CONFIG.myLon}&current=temperature_2m,wind_speed_10m,weather_code`;
            const r = await fetchWithTimeout(url, {}, 6000, 'local weather');
            const d = await r.json();
            if(d.current) {
                AI_CONFIG.weatherData = { temp: d.current.temperature_2m, wind: d.current.wind_speed_10m };
                const el = document.getElementById('weather-display');
                if(el) el.innerText = `WEATHER: ${AI_CONFIG.weatherData.temp}°C | WIND: ${AI_CONFIG.weatherData.wind} KM/H`;
            }
        } catch(e) { aiLog('DEBUG', `Weather fetch failed: ${e.message || e}`, 'debug'); }
    }

    async function updateReceiverLocation() {
        try {
            const dom = document.getElementById('receiver-info');
            if (dom && dom.innerText.includes('Lat')) {
                const t = dom.innerText;
                const lat = t.match(/Lat:?\s*(-?[\d.]+)/);
                const lon = t.match(/Lon:?\s*(-?[\d.]+)/);
                if (lat && lon) { AI_CONFIG.myLat = parseFloat(lat[1]); AI_CONFIG.myLon = parseFloat(lon[1]); return; }
            }
            const r = await fetchWithTimeout(`${AI_CONFIG.dump1090Base}/receiver.json`, {}, 6000, 'dump1090 receiver');
            if(r.ok) {
                const d = await r.json();
                if(d.lat && d.lon) { AI_CONFIG.myLat = d.lat; AI_CONFIG.myLon = d.lon; }
            }
        } catch(e) {
            aiLog("AI ERROR", `Unable to read receiver coordinates: ${e.message || e}`, 'alert');
        }
    }

    function updateAiStatus(msg, color) {
        const el = document.getElementById('ai-status-text');
        if(el) { el.innerText = msg; el.style.color = color || '#fff'; }
        if (msg !== lastAiStatus.text || color !== lastAiStatus.color) {
            aiLog('DEBUG', `AI status -> ${msg} (${color || '#fff'})`, 'debug');
            lastAiStatus = { text: msg, color: color };
        }
    }

    function aiLog(title, text, type = 'normal') {
        const tick = document.getElementById('message-ticker-track');
        const time = new Date().toLocaleTimeString();
        const clean = text.replace(/\n/g, ' ');
        const payload = `[${time}] ${title}: ${clean}`;
        if(tick) tick.innerText = payload;
        msgHistory.unshift({time: time, title: title, text: clean, type: type});
        if(msgHistory.length > 50) msgHistory.pop();

        if (type === 'alert') console.error(payload);
        else if (type === 'debug') console.debug(payload);
        else console.log(payload);
    }

    document.getElementById('ai-toggle-btn').addEventListener('click', detectModel);
    document.getElementById('tts-mute-toggle').addEventListener('click', () => {
        voiceEnabled = !voiceEnabled;
        const btn = document.getElementById('tts-mute-toggle');
        const st = document.getElementById('tts-status');
        if(voiceEnabled) { btn.innerText = "MUTE"; st.innerText = "ACTIVE"; speak("Voice enabled."); }
        else { btn.innerText = "UNMUTE"; st.innerText = "MUTED"; window.speechSynthesis.cancel(); }
    });
    document.getElementById('range-increase').addEventListener('click', () => setTimeout(() => { aiProcessing=false; runAiCycle(); }, 500));
    document.getElementById('range-decrease').addEventListener('click', () => setTimeout(() => { aiProcessing=false; runAiCycle(); }, 500));
    document.getElementById('ai-persona-select').addEventListener('change', (e) => {
        setCookie("aiPersona", e.target.value, 365);
        window.speechSynthesis.cancel();
        stopSpeechSequence();
        aiLog('AI', `Persona switched to ${e.target.value}`);
        updateAiStatus("SWITCHING MODE...", "#ffff00");
        setTimeout(() => { aiProcessing=false; runAiCycle({ forceImmediate: true }); }, 100);
    });

    function getCurrentRangeLimit() {
        const el = document.getElementById('range-value');
        if (el) {
            const m = el.innerText.match(/(\d+)/);
            if (m) return parseInt(m[0], 10);
        }
        return 50; 
    }

    async function detectModel() {
        updateAiStatus("CONNECTING...", "#ffff00");
        aiLog("DEBUG", `Attempting Ollama detection across ${ollamaCandidates.length} candidates`, 'debug');

        let lastError = null;
        for (const candidate of ollamaCandidates) {
            AI_CONFIG.ollamaUrl = candidate;
            aiLog("AI", `Detecting Ollama at ${candidate}`);
            try {
                const r = await fetchWithTimeout(`${candidate}/api/tags`, {}, OLLAMA_DISCOVERY_TIMEOUT_MS, `Ollama tags @ ${candidate}`);
                if (!r.ok) throw new Error(`Status ${r.status}`);
                const d = await r.json();
                if (!d.models || d.models.length === 0) throw new Error('No models available');

                const m = d.models.find(x => x.name.includes('llama3')) || d.models[0];
                AI_CONFIG.ollamaModel = m.name;
                aiLog("AI", `Connected to ${candidate} using ${AI_CONFIG.ollamaModel}`);
                updateAiStatus("ONLINE", "#00ff41");
                return true;
            } catch (e) {
                lastError = e;
                console.error(`Ollama detection failed at ${candidate}`, e);
                aiLog("AI ERROR", `Ollama connection failed at ${candidate}: ${e.message || e}`, 'alert');
                if ((e.message || '').includes('Status 404') && candidate.includes('/ollama')) {
                    lastProxy404Candidate = candidate;
                    if (!proxyHintLogged) {
                        aiLog('DEBUG', 'Hint: /ollama returned 404 — ensure your lighttpd proxy forwards /ollama/* to 127.0.0.1:11434 with trailing slash preservation. Example:', 'debug');
                        aiLog('DEBUG', 'lighttpd snippet ->   $HTTP["url"].startswith("/ollama/") { proxy.server  =  ("" => (( "host" => "127.0.0.1", "port" => 11434 ))) }', 'debug');
                        proxyHintLogged = true;
                    }
                }
                if ((e.message || '').includes('Status 403')) {
                    lastCorsForbiddenCandidate = candidate;
                    if (!corsForbiddenHintLogged) {
                        const origin = window.location.origin;
                        aiLog('DEBUG', `403 Forbidden from ${candidate} — Ollama is rejecting browser Origin. Set OLLAMA_ORIGINS="${origin}" (or your dashboard URL) and restart Ollama.`, 'debug');
                        aiLog('DEBUG', `Server check: curl -i -H "Origin: ${origin}" http://127.0.0.1:11434/api/tags should return 200 with Access-Control-Allow-Origin`, 'debug');
                        aiLog('DEBUG', 'If using systemd, add OLLAMA_ORIGINS to /etc/systemd/system/ollama.service.d/override.conf then daemon-reload + restart.', 'debug');
                        aiLog('DEBUG', `If wildcard (*) is set but 403 persists, pin explicit origins: export OLLAMA_ORIGINS="${origin},http://${window.location.hostname}" && systemctl restart ollama`, 'debug');
                        aiLog('DEBUG', 'Verify the environment is active with: systemctl show ollama.service | grep OLLAMA_ORIGINS', 'debug');
                        corsForbiddenHintLogged = true;
                    }
                }
                if ((e.message || '').includes('Failed to fetch') && !corsProbeLogged[candidate]) {
                    if (candidate.includes(':11434')) {
                        lastCorsBlockedCandidate = candidate;
                    }
                    corsProbeLogged[candidate] = true;
                    probeOllamaReachability(candidate);
                    if (candidate.includes(':11434') && !corsEnvHintLogged) {
                        aiLog('DEBUG', 'If direct port 11434 is reachable but blocked by the browser, set OLLAMA_ORIGINS="*" (or your dashboard URL) before starting Ollama, e.g.:', 'debug');
                        aiLog('DEBUG', '  export OLLAMA_ORIGINS="*" && export OLLAMA_HOST=0.0.0.0 && systemctl restart ollama', 'debug');
                        corsEnvHintLogged = true;
                    }
                }
                if (!serverDiagnosticsLogged) {
                    const origin = window.location.origin;
                    let proxyPath = '/ollama';
                    try {
                        const parsed = new URL(candidate);
                        proxyPath = parsed.pathname || proxyPath;
                    } catch (err) {
                        console.debug('Falling back to default proxy path hint', err);
                    }

                    const cleanProxyPath = proxyPath.replace(/\/$/, '');
                    aiLog('DEBUG', `Server-side tests: curl -i http://127.0.0.1:11434/api/tags ; curl -i -H "Origin: ${origin}" http://127.0.0.1:11434/api/tags ; if proxying, curl -i http://127.0.0.1${cleanProxyPath}/api/tags`, 'debug');
                    serverDiagnosticsLogged = true;
                }
            }
        }

        updateAiStatus("ERROR", "#ff3333");
        if (lastError) {
            aiLog("AI ERROR", `No Ollama endpoint reachable (${lastError.message || lastError}).`, 'alert');
        }

        logOllamaRemediation();
        return false;
    }

    async function probeOllamaReachability(candidate) {
        const url = `${candidate}/api/tags`;
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), 4000);
        const started = performance.now();
        try {
            aiLog('DEBUG', `Probing reachability without CORS @ ${url}`, 'debug');
            const resp = await fetch(url, { mode: 'no-cors', signal: controller.signal });
            const elapsed = Math.round(performance.now() - started);
            clearTimeout(timer);
            if (resp && resp.type === 'opaque') {
                lastOpaqueCandidate = candidate;
                aiLog('DEBUG', `Ollama responded (opaque/no-cors) in ${elapsed}ms — service reachable but CORS/proxy headers are missing. Add Access-Control-Allow-Origin:* on Ollama or forward /ollama/* via lighttpd.`, 'debug');
            } else {
                aiLog('DEBUG', `No-cors probe returned type=${resp && resp.type}, status=${resp && resp.status} in ${elapsed}ms`, 'debug');
            }
        } catch (probeErr) {
            clearTimeout(timer);
            aiLog('DEBUG', `No-cors probe failed at ${candidate}: ${probeErr.message || probeErr}`, 'debug');
        }
    }

    async function runAiSelfTest() {
        const candidates = resolveOllamaCandidates();
        aiLog('DEBUG', `Self-test: checking ${candidates.length} Ollama candidate(s): ${candidates.join(', ')}`, 'debug');

        for (const candidate of candidates) {
            try {
                const resp = await fetchWithTimeout(`${candidate}/api/tags`, {}, OLLAMA_SELF_TEST_TIMEOUT_MS, `Self-test tags @ ${candidate}`);
                const summary = `Self-test: ${candidate} responded with status ${resp.status} (type=${resp.type})`;
                if (resp.status === 403) {
                    lastCorsForbiddenCandidate = candidate;
                    aiLog('DEBUG', `${summary} — add OLLAMA_ORIGINS for ${window.location.origin} or enable /ollama proxy.`, 'debug');
                } else {
                    aiLog(resp.ok ? 'AI' : 'DEBUG', summary, resp.ok ? 'normal' : 'debug');
                }
            } catch (e) {
                aiLog('DEBUG', `Self-test (cors) failed at ${candidate}: ${e.message || e}`, 'debug');
            }

            await probeOllamaReachability(candidate);
        }

        aiLog('DEBUG', 'Self-test complete. If every candidate returns 404, confirm your lighttpd proxy forwards /ollama/* to 127.0.0.1:11434 and preserves trailing slashes.', 'debug');
        logOllamaRemediation();
    }

    async function runAiCycle(options = {}) {
        const { forceImmediate = false } = options;
        if (!systemActive || aiProcessing) return;
        if (isSpeaking) return; // Watchdog prevents overlap
        if (!AI_CONFIG.ollamaModel) { detectModel(); return; }

        const now = Date.now();
        const timeSinceLast = now - lastCommentaryTimestamp;
        if (!forceImmediate && timeSinceLast < COMMENTARY_COOLDOWN_MS) {
            const remainingSeconds = Math.ceil((COMMENTARY_COOLDOWN_MS - timeSinceLast) / 1000);
            aiLog('DEBUG', `Cooldown active; ${remainingSeconds}s until next commentary window`, 'debug');
            return;
        }

        if (forceImmediate) {
            aiLog('DEBUG', 'Cooldown bypassed due to persona switch', 'debug');
        }

        aiProcessing = true;
        try {
            aiLog('DEBUG', `AI cycle start (range=${getCurrentRangeLimit()}km, model=${AI_CONFIG.ollamaModel})`, 'debug');
            await updateReceiverLocation();
            const r = await fetchWithTimeout(`${AI_CONFIG.dump1090Base}/aircraft.json`, {}, 7000, 'dump1090 aircraft');
            if (!r.ok) throw new Error(`dump1090 status ${r.status}`);
            const d = await r.json();
            const valid = (d.aircraft || []).filter(p => p.lat && p.lon && (p.seen||0)<60);
            const enriched = valid.map(p => ({
                id: (p.flight || "UFO").trim(),
                type: p.t || "Unknown", squawk: p.squawk || "0000",
                alt: p.alt_baro || 0, speed: p.gs || 0,
                lat: p.lat, lon: p.lon, track: p.track || 0, vertRate: p.baro_rate || 0,
                dist: getDistance(AI_CONFIG.myLat, AI_CONFIG.myLon, p.lat, p.lon)
            })).sort((a, b) => a.dist - b.dist);

            const limit = getCurrentRangeLimit();
            const inRange = enriched.filter(p => p.dist < limit);

            if (inRange.length > 0) {
                updateAiStatus("ANALYZING...", "#ffff00");
                const alerts = analyzeConditions(inRange);
                const top = inRange.slice(0, AI_CONFIG.maxPlanes);
                const comms = await generateCommentary(top, inRange.length, alerts);

                const isAlert = alerts.length > 0 || top[0].dist < 15;
                if(comms.includes("7700")) {
                    document.body.classList.add('emergency-active');
                    setTimeout(() => document.body.classList.remove('emergency-active'), 5000);
                }
                aiLog(isAlert ? "ALERT" : "STATUS", comms, isAlert ? 'alert' : 'normal');
                lastCommentaryTimestamp = Date.now();
                speak(comms);
            }
        } catch (e) {
            console.error("AI processing failed", e);
            aiLog("AI ERROR", `Processing failed: ${e.message || e}`, 'alert');
            updateAiStatus("DATA ERROR", "#ff3333");
        }
        aiProcessing = false;
        aiLog('DEBUG', 'AI cycle complete', 'debug');
    }

    function analyzeConditions(planes) {
        let detected = [];
        planes.slice(0,5).forEach(p => {
            if(p.squawk === '7700') detected.push(`EMERGENCY: ${p.id} 7700.`);
            const b = calculateBearing(p.lat, p.lon, AI_CONFIG.myLat, AI_CONFIG.myLon);
            let d = Math.abs(p.track - b); if(d>180) d=360-d;
            if(d<20 && p.dist<50) detected.push(`${p.id} INBOUND.`);
        });
        return detected;
    }

    async function generateCommentary(targets, count, alerts) {
        const key = document.getElementById('ai-persona-select').value;
        let persona = PERSONAS[key];
        if(key==='ATC' && AI_CONFIG.locationName) persona = persona.replace("{LOCATION}", AI_CONFIG.locationName.toUpperCase());

        const styleHint = PERSONA_STYLE_HINTS[key] || '';

        const report = targets.map(p => {
            const trend = p.vertRate > 500 ? `climbing ${p.vertRate}fpm` : p.vertRate < -500 ? `descending ${Math.abs(p.vertRate)}fpm` : 'level';
            return `${p.id}: Rng ${p.dist.toFixed(0)}km, Alt ${p.alt}ft, Hdg ${(p.track || 0).toFixed(0)}°, Spd ${Math.round(p.speed || 0)}kts, Trend ${trend}.`;
        }).join("\n");
        const density = count > 15 ? "HEAVY" : count > 5 ? "MODERATE" : "LIGHT";

        const tasking = key === 'MILITARY'
            ? 'TASK: One persona-tuned line under 40 words. Lead with threat calls and pattern/intent analysis (hot/cold, intercept posture, formation spacing, racetrack/holding). Skip raw telemetry (ranges, altitudes, speeds); focus on tactical picture, threat priority, and shifts.'
            : 'TASK: One persona-tuned line under 40 words. Lead with alerts, then priority contacts with range/altitude/heading/speed/trend and any intent (hot/cold, holding, intercept, formation, base approach). Note overall density and any pattern shifts.';

        const prompt = `TIME: ${new Date().toLocaleTimeString()}. WEATHER: ${AI_CONFIG.weatherData ? AI_CONFIG.weatherData.temp+"C" : "?"}.
        TRAFFIC: ${count} (Density: ${density}). LIST: ${report}. ALERTS: ${alerts.join(",") || "None"}.
        ${tasking} Apply style: ${styleHint}. No greetings, filler, or questions.`;

        try {
            aiLog('PROMPT', `[${key}] System: ${persona} | Prompt: ${prompt}`, 'debug');
            const r = await fetchWithTimeout(`${AI_CONFIG.ollamaUrl}/api/chat`, {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ model: AI_CONFIG.ollamaModel, messages: [{role:"system", content:persona}, {role:"user", content:prompt}], stream: false })
            }, OLLAMA_CHAT_TIMEOUT_MS, `Ollama chat @ ${AI_CONFIG.ollamaUrl}`);
            if (!r.ok) throw new Error(`Status ${r.status}`);
            return (await r.json()).message.content.trim();
        } catch (e) {
            console.error("Ollama chat request failed", e);
            aiLog("AI ERROR", `Chat request failed: ${e.message || e}`, 'alert');
            updateAiStatus("ERROR", "#ff3333");
            return "AI COMMS LINK DOWN.";
        }
    }

    function getDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; const dLat = (lat2-lat1)*Math.PI/180; const dLon = (lon2-lon1)*Math.PI/180;
        const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180) * Math.sin(dLon/2)**2;
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }
    function calculateBearing(lat1, lon1, lat2, lon2) {
        const y = Math.sin((lon2-lon1)*Math.PI/180) * Math.cos(lat2*Math.PI/180);
        const x = Math.cos(lat1*Math.PI/180)*Math.sin(lat2*Math.PI/180) - Math.sin(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.cos((lon2-lon1)*Math.PI/180);
        return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    }
    function setCookie(n, v, d) {
        const days = Number.isFinite(d) ? d : 30;
        const expires = new Date(Date.now() + days * 24 * 60 * 60 * 1000).toUTCString();
        document.cookie = `${n}=${v || ''}; path=/; expires=${expires}`;
    }
    function getCookie(n) { const m = document.cookie.match(new RegExp('(^| )' + n + '=([^;]+)')); return m ? m[2] : null; }
  </script>
</body>
</html>
